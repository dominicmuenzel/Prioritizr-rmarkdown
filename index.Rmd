---
title: "RMrk"
author: "Dominic Muenzel"
date: "2023-06-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
  
<br>
  
  
This is an R Markdown tutorial on using prioritizr https://prioritizr.net/ to perform conservation planning.

# Importing libraries


  
```{r, warning=FALSE,message=FALSE}
library(dplyr)
library(tidyr)
library(sp)
library(sf)
library(raster)
library(rgeos)
library(geodata)
library(terra)
```

# Study area and planning unit grid
  
In this example, our planning region will be Aceh, Indonesia. 
  
```{r, warning=FALSE,message=FALSE,eval=TRUE}

#Download Indonesia shapefile
study_area <- gadm(country="IDN", level=1, path=tempdir()) 

#Subset to Aceh
study_area <- study_area %>% terra::subset(NAME_1=="Aceh",NSE=T) %>% as( "Spatial")

#Transform to projected CRS
study_area_utm <-   CRS("+proj=aea +lat_0=-15 +lon_0=125 +lat_1=7 +lat_2=-32 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs") %>% 
  spTransform(study_area, .)


```

Next, we will create a hexagonal planning unit grid. The code below is adapted from a M. Strimas Mackey [tutorial](https://strimas.com/post/hexagonal-grids/#:~:text=Creating%20grids-,Hexagonal%20grids,grid%20of%20polygons%20with%20HexPoints2SpatialPolygons%20.).

```{r, warning=FALSE,message=FALSE,eval=TRUE}
#This function generates a planning unit grid. 'x' is a projected shapefile of the region. 'type' is either square or hexagonal. 'cell_width' or 'cell_area' is supplied in units of the projection. 'clip' determines whether the grid is clipped (TRUE) or not (FALSE) to the region
make_grid <- function(x, type, cell_width, cell_area, clip = FALSE) {
  if (!type %in% c("square", "hexagonal")) {
    stop("Type must be either 'square' or 'hexagonal'")
  }

  if (missing(cell_width)) {
    if (missing(cell_area)) {
      stop("Must provide cell_width or cell_area")
    } else {
      if (type == "square") {
        cell_width <- sqrt(cell_area)
      } else if (type == "hexagonal") {
        cell_width <- sqrt(2 * cell_area / sqrt(3))
      }
    }
  }
  # buffered extent of study area to define cells over
  ext <- as(extent(x) + cell_width, "SpatialPolygons")
  projection(ext) <- projection(x)
  # generate grid
  if (type == "square") {
    g <- raster(ext, resolution = cell_width)
    g <- as(g, "SpatialPolygons")
  } else if (type == "hexagonal") {
    # generate array of hexagon centers
    g <- spsample(ext, type = "hexagonal", cellsize = cell_width, offset = c(0, 0))
    # convert center points to hexagons
    g <- HexPoints2SpatialPolygons(g, dx = cell_width)
  }

  # clip to boundary of study area
  if (clip) {
    g <- gIntersection(g, x, byid = TRUE)
  } else {
    g <- g[x, ]
  }
  # clean up feature IDs
  row.names(g) <- as.character(1:length(g))

  #Convert to SpatialPolygonsDataframe with column of ID
  g <- SpatialPolygonsDataFrame(g, data.frame("ID"=row.names(g)))

  # Calculate the area for each polygon
  g$area <- as.numeric(gArea(g,byid=T))

  return(g)
}

#Make a 100km2 hexagonal grid clipped to Aceh
hex_grid<-make_grid(x=study_area_utm, type = "hexagonal", cell_area = 100000000, clip = TRUE)

#Plot the Aceh shapefile and planning unit grid
plot(study_area_utm,col = "grey50", bg = "light blue", axes = TRUE, cex = 20)
text(ext(study_area_utm)[2], ext(study_area_utm)[4]*.99, paste0("Study Area:\n",study_area_utm$NAME_1))
plot(hex_grid, border = "orange",add=T)

```

We can see that the planning unit grid has a data frame containing IDs and areas (in m^2^). Planning units should have unique IDs.

```{r, warning=FALSE,message=FALSE,eval=TRUE}
head(hex_grid)
```

#Import conservation features data