---
title: "prioritizr tutorial"
author: "Dominic Muenzel (dm710@kent.ac.uk)"
date: "2023-06-07"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
  
<br>

# Introduction  
  
This is an R Markdown tutorial on using *prioritizr* https://prioritizr.net/ to perform spatial conservation planning. 

Prioritizr supports a broad range of objectives, constraints, and penalties allowing you to answer custom-tailored conservation planning exercises.

Elements it can incorporate include multiple management zones, structural connectivity, functional connectivity, amongst others.

The algorithm solvers provide optimal solutions (whereas most tools such as Marxan generate near-optimal solutions), and are orders of magnitude faster if using the commercial Gurobi solver https://www.gurobi.com/ which anyone with an academic e-mail can get for free. 


<br>

# 1. Importing libraries

```{r, warning=FALSE,message=FALSE}
library(dplyr)
library(tidyr)
library(sp)
library(sf)
library(raster)
library(rgeos)
library(geodata)
library(terra)
library(rgdal)
library(prioritizr)
library(lwgeom)

```
<br>

# 2. Setting up study area and planning unit grid
  
In this example, our planning region will be Aceh, Indonesia. 
  
```{r, warning=FALSE,message=FALSE,eval=TRUE}

unzip("study_area_utm.zip")
study_area_utm <- readOGR(dsn = ".", layer = "study_area_utm" )


```
<br>

Next, we will create a hexagonal planning unit grid. A planning unit is a spatial management unit which is either selected or not selected in a solution.

The code below is adapted from a M. Strimas Mackey [tutorial](https://strimas.com/post/hexagonal-grids/#:~:text=Creating%20grids-,Hexagonal%20grids,grid%20of%20polygons%20with%20HexPoints2SpatialPolygons%20.). If you check out the link you can read about the benefits and drawbacks of hexagonal vs square planning units.



```{r, warning=FALSE,message=FALSE,eval=TRUE}
# this function generates a planning unit grid. 'x' is a projected shapefile of the region. 'type' is either square or hexagonal. 'cell_width' or 'cell_area' is supplied in units of the projection. 'clip' determines whether the grid is clipped (TRUE) or not (FALSE) to the region
make_grid <- function(x, type, cell_width, cell_area, clip = FALSE) {
  if (!type %in% c("square", "hexagonal")) {
    stop("Type must be either 'square' or 'hexagonal'")
  }

  if (missing(cell_width)) {
    if (missing(cell_area)) {
      stop("Must provide cell_width or cell_area")
    } else {
      if (type == "square") {
        cell_width <- sqrt(cell_area)
      } else if (type == "hexagonal") {
        cell_width <- sqrt(2 * cell_area / sqrt(3))
      }
    }
  }
  # buffered extent of study area to define cells over
  ext <- as(extent(x) + cell_width, "SpatialPolygons")
  projection(ext) <- projection(x)
  # generate grid
  if (type == "square") {
    g <- raster(ext, resolution = cell_width)
    g <- as(g, "SpatialPolygons")
  } else if (type == "hexagonal") {
    # generate array of hexagon centers
    g <- spsample(ext, type = "hexagonal", cellsize = cell_width, offset = c(0, 0))
    # convert center points to hexagons
    g <- HexPoints2SpatialPolygons(g, dx = cell_width)
  }

  # clip to boundary of study area
  if (clip) {
    g <- gIntersection(g, x, byid = TRUE)
  } else {
    g <- g[x, ]
  }
  # clean up feature IDs
  row.names(g) <- as.character(1:length(g))

  #Convert to SpatialPolygonsDataframe with column of ID
  g <- SpatialPolygonsDataFrame(g, data.frame("ID"=row.names(g)))

  # Calculate the area for each polygon
  g$area <- as.numeric(gArea(g,byid=T))

  return(g)
}

# make a 100km2 hexagonal grid clipped to Aceh. Note that because the CRS is in meters, the cell area is in meters squared. 
hex_grid<-make_grid(x=study_area_utm, type = "hexagonal", cell_area = 100000000, clip = TRUE)

# plot the Aceh shapefile and planning unit grid
plot(study_area_utm,col = "grey50", bg = "light blue", axes = TRUE, cex = 20)
text(ext(study_area_utm)[2], ext(study_area_utm)[4]*.99, paste0("Study Area:\n",study_area_utm$NAME_1))
plot(hex_grid, border = "orange",add=T)

```
<br>

We can see that the planning unit grid has a data frame containing IDs and areas (in m^2^). Planning units should have unique IDs.


```{r, warning=FALSE,message=FALSE,eval=TRUE}
head(hex_grid)
```
<br>

In this case our planning unit grid is a shapefile, but *prioritizr* also accepts raster planning unit grids. 

<br>

# 3. Preparing conservation features

Now we will import some example conservation feature data. 

'animals.zip' contains the species ranges for nine species of terrestrial mammals from the IUCN Red List database and can be found [here](https://github.com/dominicmuenzel/Prioritizr-rmarkdown/blob/main/animals.zip). 

Conservation features can also be habitat types, ecosystem services, or landscape metrics (e.g. connectivity). They can be presence-absence or continuous data. There is no limit as to how many conservation features can be included in a problem.

```{r, warning=FALSE,message=FALSE,eval=TRUE,results='hide'}

unzip("animals.zip")
animals <- readOGR(dsn = ".", layer = "animals" )
plot(animals)
```
<br>

We need to calculate how much of each conservation feature is contained within each planning unit. In ArcGIS this can be done with the **tabulate intersection** tool.
```{r, warning=FALSE,message=FALSE,eval=TRUE}

# intersect grid with features
i <- intersect(hex_grid, animals)

# compute area
i$area <- abs(area(i))

# get the attribute table
d <- data.frame(i)

# aggregate and sum the areas
m <- aggregate(d[, 'area', drop=FALSE], d[, c('ID', 'binomial')], sum)

```
<br>

Next we want to create three sets of data frames.  

  * **puDF** describes the planning units and has two columns: 
    + planning unit IDs
    + planning unit areas
  * **featuresDF** describes the conservation features and has two columns:
    + conservation features IDs 
    + conservation features names
  * **rijDF** gives how much of each conservation is in each planning unit and has three columns:
    + planning unit IDs
    + conservation features IDs
    + amount of conservation feature in the planning unit

```{r, warning=FALSE,message=FALSE,eval=TRUE}

#Area of planning units changed to km2 instead of m2, as prioritizr will give a warning message if values are too high 
puDF<-data.frame("id"=as.numeric(hex_grid$ID),"cost"=hex_grid$area/1e6)


featuresDF<-data.frame("id"=as.numeric(as.factor(sort(unique(m$binomial))
)),"name"=sort(unique(m$binomial)))

#Area of conservation features in planning units changed to km2 instead of m2, as prioritizr will give a warning message if values are too high 
rijDF<-data.frame("pu"=as.numeric(m$ID),"species"=featuresDF$id[match(m$binomial,featuresDF$name)],"amount"=m$area/1e6)
```
<br>

# 4. Running prioritisation

## 4.1. Minimum set objective

In this first scenario, we use a **minimum set objective**, which means we seek to minimise the cost of the solution (similar to Marxan). We set a target to protect 30% of nine species ranges.

As the cost, we use the area of the planning units. If we had other cost layers, we could use these instead. Examples include land acquisition costs, management costs, restoration costs, accessibility costs, and opportunity costs. 

```{r, warning=FALSE,message=FALSE,eval=TRUE,results='hide'}


#Create the prioritizr problem
p1 <- problem(puDF, featuresDF, cost_column = "cost",rij = rijDF) %>%
  
  #Add minimum set objective 
  add_min_set_objective() %>%
  
  #Add relative targets, 30% target for all species ranges
  add_relative_targets(rep(0.3,nrow(featuresDF))) %>%
  
  #Add the default solver, a gap of 0 means find the optimal solution, a gap of 0.1 means find a solution within 10% optimality
  add_default_solver(gap=0) %>%

  #Add binary decisions of either selecting or not selecting planning units
  add_binary_decisions() 

#Solve the conservation planning problem
s1<-solve(p1)

#Create a vector for colouring the planning units 
colorvector<-ifelse(s1$solution_1==1,"blue",NA)

#Plot the solution
plot(study_area_utm,col = "grey50", bg = "light blue", axes = TRUE, cex = 20)
text(ext(study_area_utm)[2], ext(study_area_utm)[4]*.99, paste0("Study Area:\n",study_area_utm$NAME_1))
plot(hex_grid, col=colorvector,border = "orange",add=T)
legend(ext(study_area_utm)[2]*.99, ext(study_area_utm)[4]*.87, legend=c("Not selected", "Selected"),
       fill=c(NA, "blue"),  cex=0.8,bg=NA)
```
<br>

We can evaluate the performance of the solution to see, for example, how many planning units are selected, what the total cost is, how well conservation features are captured in the solution.

```{r, warning=FALSE,message=FALSE,eval=TRUE}

#Calculate planning unit number statistic
eval_n_summary(p1, data.frame(s1$solution_1))

#Calculate cost statistic
eval_cost_summary(p1, data.frame(s1$solution_1))

#Plot showing proportion of species ranges protected
featureSUM<-eval_feature_representation_summary(p1, data.frame(s1$solution_1)) %>% data.frame()
barplot(featureSUM$relative_held, names.arg=rownames(featureSUM),horiz=TRUE,las=2,xlab="Proportion protected")
abline(v = 0.3, col = "red")

```
<br>

## 4.2. Other objectives

There are many other objectives which can be used, these are described [here](https://cran.r-project.org/web/packages/prioritizr/vignettes/package_overview.html) 


* **Maximum cover objective:** Represent at least one instance of as many features as possible within a given budget
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_max_cover_objective(budget = X)
```

* **Maximum features objective:** Fulfill as many targets as possible while ensuring that the cost of the solution does not exceed a budget
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_max_features_objective(budget = X)
```


* **Minimum shortfall objective:** Minimise the overall (weighted sum) shortfall for as many targets as possible while ensuring that the cost of the solution does not exceed a budget.
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_min_shortfall_objective(budget = X)
```

* **Minimum largest shortfall objective:** Minimise the largest (maximum) shortfall while ensuring that the cost of the solution does not exceed a budget.
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_min_largest_shortfall_objective(budget = X)
```

* **Maximum phylogenetic diversity objective:** Maximize the phylogenetic diversity of the features represented in the solution subject to a budget
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_max_phylo_div_objective(budget = X,tree = Y)
```
* **Maximum phylogenetic endemism objective:** Maximize the phylogenetic endemism of the features represented in the solution subject to a budget
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_max_phylo_end_objective(budget = X,tree = Y)
```

* **Maximum utility objective:** Secure as much of the features as possible without exceeding a budget. 
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_max_utility_objective(budget = X)
```
<br>

## 4.3. Target setting

Targets specify the minimum amount or proportion of a featureâ€™s distribution that needs to be protected in the solution. Not all objectives need or can be combined with targets. Different targets can be set for different features.

* **Absolute targets:** The total amount of each feature in the study area that needs to be secured. 
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_min_set_objective() %>% add_absolute_targets(X)
```
<br>

* **Relative targets:** The proportion of each feature in the study area that needs to be secured. 
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_min_set_objective() %>% add_relative_targets(0.3)
```
<br>

* **Log-linear targets:** Targets are expressed using scaling factors and log-linear interpolation. 
```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_min_set_objective() %>% add_loglinear_targets(X)
```
<br>

## 4.4. Adding constraints

Constraints can be added so that solutions exhibit a specific property. 

* **Locked in constraints:** Certain planning units are selected in the solution from the start and kept in as solutions. Protected areas might be locked in. 

In the Aceh example, we could lock in all Protected Areas listed in https://www.protectedplanet.net/. 'wdpa aceh.zip' contains the Protected Areas in Aceh and can be found  [here](https://github.com/dominicmuenzel/Prioritizr-rmarkdown/blob/main/wdpa aceh.zip). 

```{r, warning=FALSE,message=FALSE,eval=TRUE,results='hide'}

#Load protected area shapefile
unzip("wdpa aceh.zip")
pas <- readOGR(dsn = ".", layer = "wdpa aceh" )

#Get the IDs of the planning units which are overlapping with Protected Areas. In this case we are assuming a hexagon with only a partial overlap is completely protected, but in a real world example you would probably cut the hexagon into pieces.   
overlap<-st_intersection(st_as_sf(hex_grid),st_as_sf(pas)) %>% st_drop_geometry() %>% dplyr::select("ID") %>% unname() %>% unlist ()%>% as.numeric() %>% unique()


#Add locked in constraints
p1_lck <- p1 %>% add_locked_in_constraints(locked_in=overlap)

#Solve the conservation planning problem
s1_lck<-solve(p1_lck)

#Create a vector for colouring the planning units 
colorvector<-ifelse(s1_lck$solution_1==1,"blue",NA)

#Plot the solution and protected areas
plot(study_area_utm,col = "grey50", bg = "light blue", axes = TRUE, cex = 20)
text(ext(study_area_utm)[2], ext(study_area_utm)[4]*.99, paste0("Study Area:\n",study_area_utm$NAME_1))
plot(hex_grid, col=colorvector,border = "orange",add=T)
plot(pas, border= "limegreen",col=NA,add=T)
legend(ext(study_area_utm)[2]*.99, ext(study_area_utm)[4]*.87, legend=c("Not selected", "Selected","Protected Area"),
       fill=c(NA, "blue","limegreen"),  cex=0.8,bg=NA)


```

We can see that all planning units overlapping with protected areas are selected in the solution. However, as some targets are still not met with just protected areas, two additional planning units are also selected.

If you re-run the evaluation (see 4.1.) you can compare how many planning units are selected, the cost of the solution, and what proportion of species ranges are protected.

<br>

* **Locked out constraints:** Certain planning units are never selected in the solution, for example areas which are not suitable (e.g. civil infrastructure) or highly degraded. 

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_locked_out_constraints(X)
```
<br>

* **Neighbour constraints:** Ensure that all selected planning units have at least a certain number of neighbors. 

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_neighbor_constraints(X)
```
<br>

* **Contiguity constraints:** Ensure that all selected planning units are spatially connected to each other and form spatially contiguous unit.

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>%  add_contiguity_constraints()
```
<br>

* **Feature contiguity constraints:** Ensure that each feature is represented in a contiguous unit of dispersible habitat.

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_feature_contiguity_constraints()
```
<br>

* **Linear constraints:** Ensure that all selected planning units meet certain criteria. For example, they can be used to add multiple budgets, or limit the number of planning units selected in different administrative areas within a study region (e.g., different countries).

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_linear_constraints()
```
<br>

* **Mandatory allocation constraints:** Ensure that every planning unit is allocated to a management zone in the solution.

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_mandatory_allocation_constraints()
```
<br>

## 4.5. Adding penalties

We can also add penalties to a problem to favour or penalise solutions according to a secondary objective. Unlike the constraint functions, these functions add extra information to the objective function of the optimisation function to penalise solutions that do not exhibit specific characteristics. 

* **Boundary penalties:** Add penalties to penalise solutions that are excessively fragmented.

In the Aceh example, we could calculate the shared boundaries between hexagons as well as the total perimeter of each planning unit and create a more spatially aggregated solution. We store this information in **boundDF* which contains three columns: ID from, ID to, and boundary length.  

```{r, warning=FALSE,message=FALSE,eval=TRUE,results='hide'}



#Get a list of touching borders
Touching_List <- st_touches(st_as_sf(hex_grid))

#Get lines of intersection
all.lines<-st_intersection(st_as_sf(hex_grid),st_as_sf(hex_grid))

#Measure length of lines
all.l_lines<-st_length(all.lines)

#Create a boundary data frame. Since st_length calculates in metres, here we change to kilometres.
boundDF<-data.frame("id1"=as.numeric(all.lines$ID),"id2"=as.numeric(all.lines$ID.1),"boundary"=as.numeric(all.l_lines)/1e3)

#Calculate the perimeter of each hexagon, also changed to km.
perimeters<-data.frame("ID"=hex_grid$ID,"perimeter"=as.numeric(st_perimeter(st_as_sf(hex_grid)))/1e3)

#Replace the boundary of a hexagon to itself in boundDF with the newly calculated perimeters. This step is necessary as otherwise the boundaries of a hexagon to itself is 0. 
boundDF$boundary[which(boundDF$id1==boundDF$id2)]<-perimeters$perimeter[match(boundDF$id1[which(boundDF$id1==boundDF$id2)],perimeters$ID)]

#Add boundary penalty
p1_bnd <- p1 %>% add_boundary_penalties(penalty=1,data=boundDF)

#Solve the conservation planning problem
s1_bnd<-solve(p1_bnd)

#Create a vector for colouring the planning units 
colorvector<-ifelse(s1_bnd$solution_1==1,"blue",NA)

#Plot the solution and protected areas
plot(study_area_utm,col = "grey50", bg = "light blue", axes = TRUE, cex = 20)
text(ext(study_area_utm)[2], ext(study_area_utm)[4]*.99, paste0("Study Area:\n",study_area_utm$NAME_1))
plot(hex_grid, col=colorvector,border = "orange",add=T)
legend(ext(study_area_utm)[2]*.99, ext(study_area_utm)[4]*.87, legend=c("Not selected", "Selected"),
       fill=c(NA, "blue"),  cex=0.8,bg=NA)


```
<br>

* **Connectivity penalties:** Add penalties to favour solutions that select combinations of planning units with high connectivity between them. Connectivity is quantified as symmetric connectivity in a square matrix giving strength of pairwise connections.

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_connectivity_penalties(penalty=X,data=Y)
```
<br>

* **Asymmetric connectivity penalties:** Add penalties to penalize solutions that select planning units according to a certain variable (e.g., anthropogenic pressure).

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>% add_asym_connectivity_penalties(penalty=X,data=Y)
```
<br>

* **Linear penalties:** As above but using asymmetric connectivity.

```{r, warning=FALSE,message=FALSE,eval=FALSE,results='hide'}
problem() %>%  add_linear_penalties(penalty=X,data=Y)
```
<br>

## 4.6. Decision types

Conservation planning problems involve allocating management actions to specific planning units, e.g., turning a planning unit into a protected area.  

# X. Other useful resources

Calibrating trade-offs tutorial https://cran.r-project.org/web/packages/prioritizr/vignettes/calibrating_trade-offs_tutorial.html 

Connectivity tutorial https://cran.r-project.org/web/packages/prioritizr/vignettes/connectivity_tutorial.html

Gurobi installation guide https://cran.r-project.org/web/packages/prioritizr/vignettes/gurobi_installation_guide.html

Management zones tutorial https://cran.r-project.org/web/packages/prioritizr/vignettes/management_zones_tutorial.html 

Package overview https://cran.r-project.org/web/packages/prioritizr/vignettes/package_overview.html 

Getting started https://cran.r-project.org/web/packages/prioritizr/vignettes/prioritizr.html

Publication record https://cran.r-project.org/web/packages/prioritizr/vignettes/publication_record.html

Solver benchmarks https://cran.r-project.org/web/packages/prioritizr/vignettes/solver_benchmarks.html